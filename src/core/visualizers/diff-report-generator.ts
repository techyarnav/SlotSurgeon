import { UpgradeAnalysis, UpgradeChange } from '../slot-mapper/upgrade-analyzer';
import { SlotMapping } from '../../types/slot-mapping';

export interface DiffReportOptions {
  format: 'html' | 'markdown' | 'json';
  theme: 'light' | 'dark';
  includeVisualDiff: boolean;
  includeRecommendations: boolean;
}

export class DiffReportGenerator {
  private readonly mergedOptions: DiffReportOptions;

  constructor(
    private readonly analysis: UpgradeAnalysis,
    private readonly v1Mapping: SlotMapping,
    private readonly v2Mapping: SlotMapping,
    options: Partial<DiffReportOptions> = {}
  ) {
    this.mergedOptions = {
      format: 'html',
      theme: 'light',
      includeVisualDiff: true,
      includeRecommendations: true,
      ...options
    };
  }

  generate(): string {
    switch (this.mergedOptions.format) {
      case 'html':
        return this.generateHtmlReport();
      case 'markdown':
        return this.generateMarkdownReport();
      case 'json':
        return this.generateJsonReport();
      default:
        throw new Error(`Unsupported format: ${this.mergedOptions.format}`);
    }
  }

  private generateHtmlReport(): string {
    const isDark = this.mergedOptions.theme === 'dark';


    const visualDiffSection = this.mergedOptions.includeVisualDiff
      ? this.generateVisualDiffHtml()
      : '';

    const recommendationsSection = this.mergedOptions.includeRecommendations
      ? this.generateRecommendationsHtml()
      : '';

    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Upgrade Analysis - ${this.analysis.contractName}</title>
    <style>
        ${this.getHtmlStyles(isDark)}
    </style>
</head>
<body class="${this.mergedOptions.theme}">
    <div class="container">
        <header>
            <h1>üîÑ Upgrade Safety Analysis</h1>
            <h2>${this.analysis.contractName}</h2>
            <div class="compatibility-badge ${this.analysis.compatibility.level}">
                <span class="score">${this.analysis.compatibility.score}/100</span>
                <span class="level">${this.analysis.compatibility.level.toUpperCase()}</span>
            </div>
            <p class="compatibility-desc">${this.analysis.compatibility.description}</p>
        </header>

        <div class="summary-section">
            <h3>üìä Version Comparison</h3>
            <div class="version-comparison">
                <div class="version-card">
                    <h4>Version 1 (Current)</h4>
                    <div class="stats">
                        <div class="stat">Slots: ${this.analysis.v1Summary.totalSlots}</div>
                        <div class="stat">Variables: ${this.analysis.v1Summary.variables}</div>
                        <div class="stat">Packed: ${this.analysis.v1Summary.packedSlots}</div>
                    </div>
                </div>
                <div class="version-arrow">‚Üí</div>
                <div class="version-card">
                    <h4>Version 2 (New)</h4>
                    <div class="stats">
                        <div class="stat">Slots: ${this.analysis.v2Summary.totalSlots}</div>
                        <div class="stat">Variables: ${this.analysis.v2Summary.variables}</div>
                        <div class="stat">Packed: ${this.analysis.v2Summary.packedSlots}</div>
                    </div>
                </div>
            </div>

            <div class="growth-metrics">
                <div class="metric">
                    <span class="label">Storage Growth:</span>
                    <span class="value ${this.analysis.storageGrowth.slotsAdded > 0 ? 'positive' : 'neutral'}">
                        ${this.analysis.storageGrowth.slotsAdded > 0 ? '+' : ''}${this.analysis.storageGrowth.slotsAdded} slots
                    </span>
                </div>
                <div class="metric">
                    <span class="label">Efficiency Change:</span>
                    <span class="value ${this.analysis.storageGrowth.efficiencyChange >= 0 ? 'positive' : 'negative'}">
                        ${this.analysis.storageGrowth.efficiencyChange > 0 ? '+' : ''}${this.analysis.storageGrowth.efficiencyChange}%
                    </span>
                </div>
            </div>
        </div>

        <div class="changes-section">
            <h3>üîç Detected Changes</h3>
            ${this.generateChangesHtml()}
        </div>

        ${visualDiffSection}

        ${recommendationsSection}

        <footer>
            <p>Generated by SlotSurgeon ‚Ä¢ ${new Date().toISOString()}</p>
        </footer>
    </div>
</body>
</html>`;
  }

  private generateChangesHtml(): string {
    if (this.analysis.changes.length === 0) {
      return '<p class="no-changes">No storage layout changes detected.</p>';
    }

    const changesByType = this.groupChangesByType(this.analysis.changes);
    let html = '';

    Object.entries(changesByType).forEach(([type, changes]) => {
      html += `<div class="change-group">
        <h4 class="change-type-header ${type}">${this.getChangeTypeLabel(type)} (${changes.length})</h4>
        <div class="changes-list">`;

      changes.forEach(change => {
        html += `<div class="change-item ${change.severity}">
          <div class="change-icon">${this.getChangeIcon(change.type)}</div>
          <div class="change-content">
            <div class="change-description">${change.description}</div>
            ${change.recommendation ? `<div class="change-recommendation">${change.recommendation}</div>` : ''}
          </div>
          <div class="severity-badge ${change.severity}">${change.severity}</div>
        </div>`;
      });

      html += `</div></div>`;
    });

    return html;
  }

  private generateVisualDiffHtml(): string {
    return `<div class="visual-diff-section">
      <h3>üìã Visual Storage Diff</h3>
      <div class="diff-container">
        <div class="diff-column">
          <h4>Version 1 (Before)</h4>
          <div class="storage-layout">
            ${this.generateStorageLayoutHtml(this.v1Mapping, 'v1')}
          </div>
        </div>
        <div class="diff-column">
          <h4>Version 2 (After)</h4>
          <div class="storage-layout">
            ${this.generateStorageLayoutHtml(this.v2Mapping, 'v2')}
          </div>
        </div>
      </div>
    </div>`;
  }

  private generateStorageLayoutHtml(mapping: SlotMapping, version: string): string {
    let html = '';
    for (let slot = 0; slot < mapping.totalSlots; slot++) {
      const varsInSlot = mapping.variables.filter(v => v.slot === slot);
      const isPacked = mapping.packedSlots.includes(slot);

      html += `<div class="storage-slot ${isPacked ? 'packed' : ''}" data-slot="${slot}">
        <div class="slot-label">S${slot.toString().padStart(3, '0')}</div>
        <div class="slot-variables">`;

      if (varsInSlot.length === 0) {
        html += '<div class="empty-slot">Empty</div>';
      } else {
        varsInSlot.forEach(variable => {
          const changeType = this.getVariableChangeType(variable, version);
          html += `<div class="variable ${changeType}" title="${variable.name}: ${variable.type}">
            ${variable.name} (${variable.size}b)
          </div>`;
        });
      }

      html += `</div></div>`;
    }
    return html;
  }

  private generateRecommendationsHtml(): string {
    return `<div class="recommendations-section">
      <h3>üí° Recommendations</h3>
      <div class="recommendations-list">
        ${this.analysis.recommendations.map(rec =>
          `<div class="recommendation-item">
            <div class="recommendation-icon">üí°</div>
            <div class="recommendation-text">${rec}</div>
          </div>`
        ).join('')}
      </div>
    </div>`;
  }

  private generateMarkdownReport(): string {
    const compatibilityEmoji = this.getCompatibilityEmoji(this.analysis.compatibility.level);

    return `# üîÑ Upgrade Safety Analysis - ${this.analysis.contractName}

## ${compatibilityEmoji} Compatibility Score: ${this.analysis.compatibility.score}/100 (${this.analysis.compatibility.level.toUpperCase()})

${this.analysis.compatibility.description}

## üìä Version Comparison

| Metric | Version 1 | Version 2 | Change |
|--------|-----------|-----------|---------|
| Total Slots | ${this.analysis.v1Summary.totalSlots} | ${this.analysis.v2Summary.totalSlots} | ${this.analysis.storageGrowth.slotsAdded >= 0 ? '+' : ''}${this.analysis.storageGrowth.slotsAdded} |
| Variables | ${this.analysis.v1Summary.variables} | ${this.analysis.v2Summary.variables} | ${this.analysis.v2Summary.variables - this.analysis.v1Summary.variables >= 0 ? '+' : ''}${this.analysis.v2Summary.variables - this.analysis.v1Summary.variables} |
| Packed Slots | ${this.analysis.v1Summary.packedSlots} | ${this.analysis.v2Summary.packedSlots} | ${this.analysis.v2Summary.packedSlots - this.analysis.v1Summary.packedSlots >= 0 ? '+' : ''}${this.analysis.v2Summary.packedSlots - this.analysis.v1Summary.packedSlots} |
| Efficiency | - | - | ${this.analysis.storageGrowth.efficiencyChange >= 0 ? '+' : ''}${this.analysis.storageGrowth.efficiencyChange}% |

## üîç Detected Changes (${this.analysis.changes.length})

${this.analysis.changes.length === 0 ? 'No changes detected.' :
  this.analysis.changes.map(change =>
    `### ${this.getChangeIcon(change.type)} ${change.type.toUpperCase()} - ${change.severity.toUpperCase()}

**${change.description}**

${change.recommendation ? `üí° *Recommendation: ${change.recommendation}*` : ''}

---`
  ).join('\n\n')
}

## üí° Recommendations

${this.analysis.recommendations.map(rec => `- ${rec}`).join('\n')}

---
*Generated by SlotSurgeon on ${new Date().toISOString()}*`;
  }

  private generateJsonReport(): string {
    return JSON.stringify( {
      ...this.analysis,
      metadata: {
        generatedAt: new Date().toISOString(),
        tool: 'SlotSurgeon',
        version: '0.1.0'
      }
    }, null, 2);
  }

  private getHtmlStyles(isDark: boolean): string {
    const bg = isDark ? '#1a1a1a' : '#ffffff';
    const text = isDark ? '#ffffff' : '#333333';
    const border = isDark ? '#333333' : '#e0e0e0';


    let styles = `
      * { margin: 0; padding: 0; box-sizing: border-box; }

      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: ${bg};
        color: ${text};
        line-height: 1.6;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }

      header {
        text-align: center;
        margin-bottom: 2rem;
        padding: 2rem;
        border-bottom: 2px solid ${border};
      }

      .compatibility-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 1rem 2rem;
        border-radius: 12px;
        margin: 1rem 0;
        font-weight: bold;
      }

      .compatibility-badge.safe { background: #d4edda; color: #155724; }
      .compatibility-badge.caution { background: #fff3cd; color: #856404; }
      .compatibility-badge.unsafe { background: #f8d7da; color: #721c24; }
      .compatibility-badge.critical { background: #f5c6cb; color: #721c24; }

      .score { font-size: 1.5rem; }
      .level { font-size: 1.2rem; }

      .version-comparison {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 2rem;
        margin: 2rem 0;
      }

      .version-card {
        background: ${isDark ? '#2a2a2a' : '#f8f9fa'};
        padding: 1.5rem;
        border-radius: 12px;
        border: 1px solid ${border};
        text-align: center;
        min-width: 200px;
      }

      .version-arrow {
        font-size: 2rem;
        color: #667eea;
        font-weight: bold;
      }

      .stats {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        margin-top: 1rem;
      }

      .stat {
        padding: 0.5rem;
        background: ${isDark ? '#333333' : '#ffffff'};
        border-radius: 6px;
      }

      .growth-metrics {
        display: flex;
        justify-content: center;
        gap: 2rem;
        margin-top: 1rem;
      }

      .metric {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
      }

      .value.positive { color: #28a745; }
      .value.negative { color: #dc3545; }
      .value.neutral { color: ${text}; }

      .change-group {
        margin: 2rem 0;
        padding: 1.5rem;
        background: ${isDark ? '#2a2a2a' : '#f8f9fa'};
        border-radius: 12px;
        border: 1px solid ${border};
      }

      .change-item {
        display: flex;
        align-items: flex-start;
        gap: 1rem;
        padding: 1rem;
        margin: 0.5rem 0;
        border-radius: 8px;
        border-left: 4px solid;
      }

      .change-item.safe { border-left-color: #28a745; background: ${isDark ? '#1e3a1e' : '#f8fff8'}; }
      .change-item.warning { border-left-color: #ffc107; background: ${isDark ? '#3a3a1e' : '#fffef8'}; }
      .change-item.critical { border-left-color: #dc3545; background: ${isDark ? '#3a1e1e' : '#fff8f8'}; }

      .change-icon { font-size: 1.5rem; }
      .change-content { flex: 1; }
      .change-description { font-weight: 600; margin-bottom: 0.5rem; }
      .change-recommendation { font-style: italic; color: ${isDark ? '#aaaaaa' : '#666666'}; }

      .severity-badge {
        padding: 0.25rem 0.75rem;
        border-radius: 20px;
        font-size: 0.8rem;
        font-weight: bold;
        text-transform: uppercase;
      }

      .severity-badge.safe { background: #28a745; color: white; }
      .severity-badge.warning { background: #ffc107; color: #000; }
      .severity-badge.critical { background: #dc3545; color: white; }

      footer {
        text-align: center;
        margin-top: 3rem;
        padding: 2rem;
        border-top: 1px solid ${border};
        color: ${isDark ? '#aaaaaa' : '#666666'};
      }

      @media (max-width: 768px) {
        .version-comparison {
          flex-direction: column;
          gap: 1rem;
        }

        .version-arrow {
          transform: rotate(90deg);
        }
      }`;


    if (this.mergedOptions.includeVisualDiff) {
      styles += `

      .visual-diff-section {
        margin: 3rem 0;
      }

      .diff-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 2rem;
        margin-top: 2rem;
      }

      .storage-slot {
        display: flex;
        align-items: center;
        gap: 1rem;
        padding: 0.75rem;
        margin: 0.25rem 0;
        background: ${isDark ? '#2a2a2a' : '#f8f9fa'};
        border-radius: 6px;
        border: 1px solid ${border};
      }

      .storage-slot.packed {
        border-left: 4px solid #ffc107;
      }

      .slot-label {
        font-family: monospace;
        font-weight: bold;
        min-width: 40px;
      }

      .slot-variables {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .variable {
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 0.85rem;
        background: #667eea;
        color: white;
      }

      .variable.added { background: #28a745; }
      .variable.removed { background: #dc3545; }
      .variable.moved { background: #ffc107; color: #000; }
      .variable.changed { background: #fd7e14; }

      @media (max-width: 768px) {
        .diff-container {
          grid-template-columns: 1fr;
        }
      }`;
    }


    if (this.mergedOptions.includeRecommendations) {
      styles += `

      .recommendations-section {
        margin: 3rem 0;
        padding: 2rem;
        background: ${isDark ? '#2a2a2a' : '#f8f9fa'};
        border-radius: 12px;
        border: 1px solid ${border};
      }

      .recommendation-item {
        display: flex;
        align-items: flex-start;
        gap: 1rem;
        margin: 1rem 0;
      }

      .recommendation-icon {
        font-size: 1.5rem;
      }`;
    }

    return styles;
  }

  private groupChangesByType(changes: UpgradeChange[]): Record<string, UpgradeChange[]> {
    return changes.reduce((groups, change) => {
      if (!groups[change.type]) {
        groups[change.type] = [];
      }
      groups[change.type].push(change);
      return groups;
    }, {} as Record<string, UpgradeChange[]>);
  }

  private getChangeTypeLabel(type: string): string {
    const labels = {
      added: 'Added Variables',
      removed: 'Removed Variables',
      moved: 'Moved Variables',
      typeChanged: 'Type Changes',
      collision: 'Storage Collisions'
    };
    return labels[type as keyof typeof labels] || type;
  }

  private getChangeIcon(type: string): string {
    const icons = {
      added: '‚ûï',
      removed: '‚ûñ',
      moved: 'üîÑ',
      typeChanged: 'üîÑ',
      collision: 'üí•'
    };
    return icons[type as keyof typeof icons] || '‚ùì';
  }

  private getCompatibilityColor(level: string): string {
    const colors = {
      safe: '#28a745',
      caution: '#ffc107',
      unsafe: '#fd7e14',
      critical: '#dc3545'
    };
    return colors[level as keyof typeof colors] || '#6c757d';
  }

  private getCompatibilityEmoji(level: string): string {
    const emojis = {
      safe: '‚úÖ',
      caution: '‚ö†Ô∏è',
      unsafe: 'üö®',
      critical: 'üõë'
    };
    return emojis[level as keyof typeof emojis] || '‚ùì';
  }

  private getVariableChangeType(variable: any, version: string): string {
    return '';
  }
}
