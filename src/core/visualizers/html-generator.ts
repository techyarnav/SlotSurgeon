import { SlotMapping, StorageVariable } from '../../types/slot-mapping';
import { HeatmapData } from '../../types/visualization';

export interface HtmlOptions {
  title?: string;
  includeHeatmap?: boolean;
  includeTable?: boolean;
  includeGrid?: boolean;
  theme?: 'light' | 'dark';
}

export class HtmlGenerator {
  constructor(
    private readonly mapping: SlotMapping,
    private readonly options: HtmlOptions = {}
  ) {}

  generate(): string {
    const {
      title = `Storage Layout - ${this.mapping.contractName}`,
      includeHeatmap = true,
      includeTable = true,
      includeGrid = true,
      theme = 'light'
    } = this.options;

    const heatmapData = this.generateHeatmapData();
    const slotLayouts = this.generateSlotLayouts();

    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        ${this.getStyles(theme)}
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body class="${theme}">
    <div class="container">
        <header>
            <h1>ðŸ“Š ${title}</h1>
            <div class="stats">
                <span class="stat">Total Slots: <strong>${this.mapping.totalSlots}</strong></span>
                <span class="stat">Variables: <strong>${this.mapping.variables.length}</strong></span>
                <span class="stat">Packed Slots: <strong>${this.mapping.packedSlots.length}</strong></span>
            </div>
        </header>

        ${includeHeatmap ? this.generateHeatmapSection(heatmapData) : ''}
        ${includeGrid ? this.generateGridSection(slotLayouts) : ''}
        ${includeTable ? this.generateTableSection() : ''}

        <footer>
            <p>Generated by SlotSurgeon â€¢ ${new Date().toISOString()}</p>
        </footer>
    </div>

    <script>
        ${this.getJavaScript(heatmapData, slotLayouts)}
    </script>
</body>
</html>`;
  }

  private generateHeatmapData(): HeatmapData {
    const data: HeatmapData = {
      slots: [],
      maxUtilization: 0,
      colors: this.getHeatmapColors()
    };

    for (let slot = 0; slot < this.mapping.totalSlots; slot++) {
      const varsInSlot = this.mapping.variables.filter(v => v.slot === slot);
      const utilization = varsInSlot.reduce((sum, v) => sum + v.size, 0);
      const efficiency = (utilization / 32) * 100;

      data.slots.push( {
        slot,
        utilization,
        efficiency: Math.round(efficiency),
        variables: varsInSlot,
        isPacked: this.mapping.packedSlots.includes(slot)
      });

      data.maxUtilization = Math.max(data.maxUtilization, utilization);
    }

    return data;
  }

  private generateSlotLayouts() {
    const layouts: any[] = [];

    for (let slot = 0; slot < this.mapping.totalSlots; slot++) {
      const variables = this.mapping.variables.filter(v => v.slot === slot);
      const utilization = variables.reduce((sum, v) => sum + v.size, 0);

      layouts.push( {
        slot,
        variables,
        utilization
      });
    }

    return layouts;
  }

  private generateHeatmapSection(data: HeatmapData): string {
    return `
        <section class="heatmap-section">
            <h2>ðŸ”¥ Storage Utilization Heatmap</h2>
            <div class="heatmap-container">
                <div id="heatmap"></div>
                <div class="heatmap-legend">
                    <span class="legend-title">Utilization:</span>
                    <div class="legend-gradient">
                        <span class="legend-label">0%</span>
                        <div class="gradient-bar"></div>
                        <span class="legend-label">100%</span>
                    </div>
                </div>
            </div>
            <div class="heatmap-insights">
                <div class="insight">
                    <span class="insight-label">Most Efficient Slot:</span>
                    <span class="insight-value">${this.getMostEfficientSlot(data)}</span>
                </div>
                <div class="insight">
                    <span class="insight-label">Wasted Bytes:</span>
                    <span class="insight-value">${this.getWastedBytes(data)} bytes</span>
                </div>
            </div>
        </section>`;
  }

  private generateGridSection(layouts: any[]): string {
    return `
        <section class="grid-section">
            <h2>ðŸŽ¯ Interactive Storage Grid</h2>
            <div class="grid-container">
                <div id="storage-grid"></div>
            </div>
        </section>`;
  }

  private generateTableSection(): string {
    return `
        <section class="table-section">
            <h2>ðŸ“‹ Variable Details</h2>
            <div class="table-container">
                <table class="variables-table">
                    <thead>
                        <tr>
                            <th>Slot</th>
                            <th>Offset</th>
                            <th>Size</th>
                            <th>Type</th>
                            <th>Variable</th>
                            <th>Packed</th>
                            <th>Efficiency</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${this.mapping.variables.map(v => this.generateTableRow(v)).join('')}
                    </tbody>
                </table>
            </div>
        </section>`;
  }

  private generateTableRow(variable: StorageVariable): string {
    const efficiency = Math.round((variable.size / 32) * 100);
    const packedIcon = variable.packed ? 'âœ…' : '';

    return `
        <tr class="variable-row" data-slot="${variable.slot}">
            <td class="slot-cell">${variable.slot}</td>
            <td class="offset-cell">${variable.offset}</td>
            <td class="size-cell">${variable.size}b</td>
            <td class="type-cell">${variable.type}</td>
            <td class="name-cell">${variable.name}</td>
            <td class="packed-cell">${packedIcon}</td>
            <td class="efficiency-cell">${efficiency}%</td>
        </tr>`;
  }

  private getMostEfficientSlot(data: HeatmapData): string {
    if (data.slots.length === 0) return 'N/A';
    const maxSlot = data.slots.reduce((max, slot) =>
      slot.efficiency > max.efficiency ? slot : max
    );
    return `Slot ${maxSlot.slot} (${maxSlot.efficiency}%)`;
  }

  private getWastedBytes(data: HeatmapData): number {
    return data.slots.reduce((total, slot) =>
      total + (32 - slot.utilization), 0
    );
  }

  private getHeatmapColors(): string[] {
    return [
      '#f7fbff', '#deebf7', '#c6dbef', '#9ecae1',
      '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'
    ];
  }

  private getStyles(theme: 'light' | 'dark'): string {
    const isDark = theme === 'dark';
    const bg = isDark ? '#1a1a1a' : '#ffffff';
    const text = isDark ? '#ffffff' : '#333333';
    const border = isDark ? '#333333' : '#e0e0e0';

    return `
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: ${bg};
            color: ${text};
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 2rem;
            border-bottom: 2px solid ${border};
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-top: 1rem;
        }

        .stat {
            padding: 0.5rem 1rem;
            background: ${isDark ? '#2a2a2a' : '#f8f9fa'};
            border-radius: 8px;
            border: 1px solid ${border};
        }

        section {
            margin: 3rem 0;
            padding: 2rem;
            background: ${isDark ? '#2a2a2a' : '#f8f9fa'};
            border-radius: 12px;
            border: 1px solid ${border};
        }

        section h2 {
            margin-bottom: 1.5rem;
            color: #667eea;
        }

        .heatmap-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        #heatmap {
            width: 100%;
            height: 400px;
            border: 1px solid ${border};
            border-radius: 8px;
        }

        .heatmap-legend {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .gradient-bar {
            width: 200px;
            height: 20px;
            background: linear-gradient(to right,
                #f7fbff, #deebf7, #c6dbef, #9ecae1,
                #6baed6, #4292c6, #2171b5, #08519c);
            border-radius: 10px;
            border: 1px solid ${border};
        }

        .heatmap-insights {
            display: flex;
            justify-content: space-around;
            margin-top: 1rem;
            padding: 1rem;
            background: ${isDark ? '#333333' : '#ffffff'};
            border-radius: 8px;
        }

        .insight {
            text-align: center;
        }

        .insight-label {
            display: block;
            font-size: 0.9rem;
            color: ${isDark ? '#aaaaaa' : '#666666'};
        }

        .insight-value {
            display: block;
            font-size: 1.2rem;
            font-weight: bold;
            color: #667eea;
        }

        #storage-grid {
            width: 100%;
            height: 500px;
            border: 1px solid ${border};
            border-radius: 8px;
            overflow: auto;
        }

        .table-container {
            overflow-x: auto;
        }

        .variables-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .variables-table th,
        .variables-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid ${border};
        }

        .variables-table th {
            background: ${isDark ? '#333333' : '#f0f0f0'};
            font-weight: 600;
        }

        .variable-row:hover {
            background: ${isDark ? '#333333' : '#f0f8ff'};
        }

        .slot-cell { color: #667eea; font-weight: bold; }
        .size-cell { color: #28a745; }
        .packed-cell { text-align: center; }
        .efficiency-cell { color: #fd7e14; }

        footer {
            text-align: center;
            margin-top: 3rem;
            padding: 2rem;
            border-top: 1px solid ${border};
            color: ${isDark ? '#aaaaaa' : '#666666'};
        }

        @media (max-width: 768px) {
            .container { padding: 10px; }
            header h1 { font-size: 2rem; }
            .stats { flex-direction: column; gap: 1rem; }
            section { padding: 1rem; }
        }`;
  }

  private getJavaScript(heatmapData: HeatmapData, slotLayouts: any[]): string {
    return `

        function createHeatmap() {
            const data = ${JSON.stringify(heatmapData)};
            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const width = 800 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;

            const svg = d3.select("#heatmap")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            const colorScale = d3.scaleQuantize()
                .domain([0, 100])
                .range(data.colors);

            const slotWidth = width / data.slots.length;

            svg.selectAll(".slot")
                .data(data.slots)
                .enter()
                .append("rect")
                .attr("class", "slot")
                .attr("x", (d, i) => i * slotWidth)
                .attr("y", 0)
                .attr("width", slotWidth - 2)
                .attr("height", height)
                .attr("fill", d => colorScale(d.efficiency))
                .attr("stroke", "#fff")
                .attr("stroke-width", 1)
                .on("mouseover", function(event, d) {
                    showTooltip(event, d);
                })
                .on("mouseout", hideTooltip);


            svg.selectAll(".slot-label")
                .data(data.slots)
                .enter()
                .append("text")
                .attr("class", "slot-label")
                .attr("x", (d, i) => i * slotWidth + slotWidth/2)
                .attr("y", height + 20)
                .attr("text-anchor", "middle")
                .style("font-size", "12px")
                .text(d => \`S\${d.slot}\`);
        }


        function createStorageGrid() {
            const layouts = ${JSON.stringify(slotLayouts)};
            const margin = { top: 20, right: 20, bottom: 20, left: 60 };
            const width = 800 - margin.left - margin.right;
            const height = 500 - margin.top - margin.bottom;

            const svg = d3.select("#storage-grid")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            const slotHeight = 40;
            const byteWidth = width / 32;

            layouts.forEach((layout, slotIndex) => {
                const y = slotIndex * (slotHeight + 5);


                svg.append("rect")
                    .attr("x", 0)
                    .attr("y", y)
                    .attr("width", width)
                    .attr("height", slotHeight)
                    .attr("fill", "#f8f9fa")
                    .attr("stroke", "#e0e0e0");


                svg.append("text")
                    .attr("x", -10)
                    .attr("y", y + slotHeight/2)
                    .attr("text-anchor", "end")
                    .attr("alignment-baseline", "middle")
                    .style("font-size", "12px")
                    .text(\`S\${layout.slot}\`);


                layout.variables.forEach(variable => {
                    const variableWidth = variable.size * byteWidth;
                    const color = getVariableColor(variable.name);

                    svg.append("rect")
                        .attr("x", variable.offset * byteWidth)
                        .attr("y", y + 2)
                        .attr("width", variableWidth)
                        .attr("height", slotHeight - 4)
                        .attr("fill", color)
                        .attr("stroke", "#333")
                        .attr("opacity", 0.8)
                        .on("mouseover", function(event) {
                            showVariableTooltip(event, variable);
                        })
                        .on("mouseout", hideTooltip);


                    if (variableWidth > 30) {
                        svg.append("text")
                            .attr("x", variable.offset * byteWidth + variableWidth/2)
                            .attr("y", y + slotHeight/2)
                            .attr("text-anchor", "middle")
                            .attr("alignment-baseline", "middle")
                            .style("font-size", "10px")
                            .style("fill", "#fff")
                            .text(variable.name.substring(0, Math.floor(variableWidth/8)));
                    }
                });
            });
        }


        function getVariableColor(name) {
            const colors = ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4facfe', '#00f2fe'];
            const hash = name.split('').reduce((a, b) => (a << 5) - a + b.charCodeAt(0), 0);
            return colors[Math.abs(hash) % colors.length];
        }

        function showTooltip(event, data) {
            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("position", "absolute")
                .style("background", "rgba(0,0,0,0.8)")
                .style("color", "white")
                .style("padding", "10px")
                .style("border-radius", "5px")
                .style("pointer-events", "none")
                .style("z-index", 1000);

            tooltip.html(\`
                <strong>Slot \${data.slot}</strong><br/>
                Utilization: \${data.utilization}/32 bytes (\${data.efficiency}%)<br/>
                Variables: \${data.variables.length}<br/>
                Packed: \${data.isPacked ? 'Yes' : 'No'}
            \`)
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 10) + "px");
        }

        function showVariableTooltip(event, variable) {
            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("position", "absolute")
                .style("background", "rgba(0,0,0,0.8)")
                .style("color", "white")
                .style("padding", "10px")
                .style("border-radius", "5px")
                .style("pointer-events", "none")
                .style("z-index", 1000);

            tooltip.html(\`
                <strong>\${variable.name}</strong><br/>
                Type: \${variable.type}<br/>
                Size: \${variable.size} bytes<br/>
                Slot: \${variable.slot}<br/>
                Offset: \${variable.offset}
            \`)
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 10) + "px");
        }

        function hideTooltip() {
            d3.selectAll(".tooltip").remove();
        }


        document.addEventListener('DOMContentLoaded', function() {
            createHeatmap();
            createStorageGrid();
        });`;
  }
}
