import { Command } from 'commander';
import { SolidityParser } from '../../core/parser/solidity-parser';
import { SlotCalculator } from '../../core/slot-mapper/slot-calculator';
import { AsciiRenderer } from '../../core/visualizers/ascii-renderer';
import { TerminalVisualizer } from '../../core/visualizers/terminal-visualizer';
import { FileSystemUtils } from '../../utils/file-system';
import { OutputFormatter } from '../../utils/formatters';

export const visualizeCommand = new Command('visualize')
  .description('Render an ASCII grid of a contract storage layout')
  .argument('<solidityFile>', '.sol file path')
  .option('-c, --contract <name>', 'Specify contract name if file contains many')
  .option('-o, --output <file>', 'Save ASCII visualization to file')
  .option('-f, --format <type>', 'Output format: ascii, terminal, html, markdown, json', 'ascii')
  .option('--no-table', 'Hide detailed variable table')
  .option('--include-inheritance', 'Include inheritance visualization')
  .option('--show-collisions', 'Highlight potential storage collisions')
  .action(async (file, options) => {
    try {
      if (!(await FileSystemUtils.fileExists(file))) {
        console.error(OutputFormatter.formatError(`file not found: ${file}`));
        process.exit(1);
      }

      const parser = new SolidityParser(file);
      const contracts = await parser.parse();
      if (contracts.length === 0) {
        console.error(OutputFormatter.formatError('no contracts found'));
        process.exit(1);
      }

      let target = contracts[0];
      if (options.contract) {
        const match = contracts.find(c => c.name === options.contract);
        if (!match) {
          console.error(OutputFormatter.formatError(`contract ${options.contract} not found`));
          process.exit(1);
        }
        target = match;
      }

      const mapping = SlotCalculator.calculateSlots(target);

      if (options.format === 'terminal') {
        const visualizer = new TerminalVisualizer(mapping, target, file);
        const output = await visualizer.generate( {
          includeInheritance: options.includeInheritance,
          showCollisions: options.showCollisions,
          useColors: options.color
        });

        console.log(output);

        if (options.output) {
          const fileOutput = await visualizer.generate( {
            includeInheritance: options.includeInheritance,
            showCollisions: options.showCollisions,
            useColors: false
          });
          await FileSystemUtils.writeFile(options.output, fileOutput);
          console.log(OutputFormatter.formatSuccess(`Terminal visualization saved to ${options.output}`));
        }
      } else if (options.format === 'ascii') {
        const renderOptions = {
          color: options.color,
          legend: true,
          showTable: options.gridOnly ? false : options.table,
          showSideDetails: options.gridOnly ? false : options.sideDetails,
        };

        const consoleOutput = new AsciiRenderer(mapping, renderOptions).render();
        console.log(consoleOutput);

        if (options.output) {
          const fileOutput = new AsciiRenderer(mapping, {
            ...renderOptions,
            color: false,
          }).render();

          const header = `# Storage Layout Visualization for ${target.name}\n` +
                        `Generated by SlotSurgeon\n` +
                        `Source: ${file}\n` +
                        `Date: ${new Date().toISOString()}\n\n`;

          const content = header + fileOutput;
          await FileSystemUtils.writeFile(options.output, content);
          console.log(OutputFormatter.formatSuccess(`Visualization saved to ${options.output}`));
        }
      } else {
        console.error(OutputFormatter.formatError(`Format ${options.format} not yet implemented for visualize command`));
        console.log(OutputFormatter.formatInfo('Available formats: ascii, terminal'));
        process.exit(1);
      }

    } catch (err) {
      console.error(OutputFormatter.formatError(String(err)));
      process.exit(1);
    }
  });
